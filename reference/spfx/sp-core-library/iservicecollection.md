<span data-ttu-id="cc758-p101">Wiederverwendbare Bibliothekskomponenten deklarieren ihre Dienstabhängigkeiten in der Regel durch Aufrufen von ServiceScope.consume() mithilfe des entsprechenden ServiceKey für jeden Dienst. Für die Geschäftslogik der Anwendung oder kleine Projekte ist dieser Formalismus möglicherweise nicht erforderlich und würde die Lernkurve für Entwickler erhöhen. Als einfache Alternative können mit dem IServiceCollection-Muster gemeinsame Dienste für ein bestimmtes Szenario als eine einfache und praktische Sammlung übergeben werden. Beispielsweise kann eine Widget-Funktion die folgende Schnittstelle einführen: interface IWidgetServiceCollection extends IServiceCollection { spHttpClient: SPHttpClient; widgetManager: IWidgetManager; } Die Widget-Klasse kann dann möglicherweise eine „services“-Eigenschaft initialisieren, z. B.: property, like this: class Widget { private _services: IWidgetServiceCollection; constructor(serviceScope: ServiceScope) { serviceScope.whenFinished(() => { this._services = { serviceScope, spHttpClient: serviceScope.consume(SPHttpClient.serviceKey), widgetManager: serviceScope.consume(WidgetManager.ServiceKey), }; }); } public get services(): IWidgetServiceCollection {return diese ._services;}} Für eine Gruppe von Komponenten, die alle diese Abhängigkeiten aufweisen, kann dieses „services“-Objekt anstelle des abstrakten ServiceScope übergeben werden. Dies ermöglicht direkte Verweise, z. B. services.widgetManager, services.spHttpClient usw. Für untypische Abhängigkeiten steht weiterhin der services.serviceScope zur Verfügung. WICHTIG: Um das Muster übersichtlich und verständlich zu halten, sollte IServiceCollection NICHT mit zusätzlichen Elementen erweitert werden, bei denen es sich nicht um ServiceScope-Dienste handelt.</span><span class="sxs-lookup"><span data-stu-id="cc758-p101">Reusable library components typically declare their service dependencies by calling ServiceScope.consume() using the corresponding ServiceKey for each service. For application business logic or small-sized projects, this formalism may be unnecessary and would increase the learning curve for developers. As a lightweight alternative, the IServiceCollection pattern allows the common services for a particular scenario to be passed around as a simple, convenient collection. For example, a widget feature might introduce an interface like this: interface IWidgetServiceCollection extends IServiceCollection { spHttpClient: SPHttpClient; widgetManager: IWidgetManager; } Then the Widget class might initialize a "services" property, like this: class Widget { private _services: IWidgetServiceCollection; constructor(serviceScope: ServiceScope) { serviceScope.whenFinished(() => { this._services = { serviceScope, spHttpClient: serviceScope.consume(SPHttpClient.serviceKey), widgetManager: serviceScope.consume(WidgetManager.ServiceKey), }; }); } public get services(): IWidgetServiceCollection { return this._services; } } For a group of components that all have these dependencies, this "services" object can be passed around instead of the abstract ServiceScope. This enables direct references such as services.widgetManager, services.spHttpClient, etc. For atypical dependencies, the services.serviceScope is still available for use. IMPORTANT: To keep the pattern clean and understandable, IServiceCollection should NOT be extended with any additional members that are not ServiceScope services.</span></span>

Wiederverwendbare Bibliothekskomponenten deklarieren ihre Dienstabhängigkeiten in der Regel durch Aufrufen von ServiceScope.consume() mithilfe des entsprechenden ServiceKey für jeden Dienst. Für die Geschäftslogik der Anwendung oder kleine Projekte ist dieser Formalismus möglicherweise nicht erforderlich und würde die Lernkurve für Entwickler erhöhen. Als einfache Alternative können mit dem IServiceCollection-Muster gemeinsame Dienste für ein bestimmtes Szenario als eine einfache und praktische Sammlung übergeben werden. Beispielsweise kann eine Widget-Funktion die folgende Schnittstelle einführen: interface IWidgetServiceCollection extends IServiceCollection { spHttpClient: SPHttpClient; widgetManager: IWidgetManager; } Die Widget-Klasse kann dann möglicherweise eine „services“-Eigenschaft initialisieren, z. B.: property, like this: class Widget { private _services: IWidgetServiceCollection; constructor(serviceScope: ServiceScope) { serviceScope.whenFinished(() => { this._services = { serviceScope, spHttpClient: serviceScope.consume(SPHttpClient.serviceKey), widgetManager: serviceScope.consume(WidgetManager.ServiceKey), }; }); } public get services(): IWidgetServiceCollection {return diese ._services;}} Für eine Gruppe von Komponenten, die alle diese Abhängigkeiten aufweisen, kann dieses „services“-Objekt anstelle des abstrakten ServiceScope übergeben werden. Dies ermöglicht direkte Verweise, z. B. services.widgetManager, services.spHttpClient usw. Für untypische Abhängigkeiten steht weiterhin der services.serviceScope zur Verfügung. WICHTIG: Um das Muster übersichtlich und verständlich zu halten, sollte IServiceCollection NICHT mit zusätzlichen Elementen erweitert werden, bei denen es sich nicht um ServiceScope-Dienste handelt.

