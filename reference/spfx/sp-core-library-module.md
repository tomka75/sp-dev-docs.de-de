# <a name="sp-core-library-module"></a>sp-core-library-Modul



## <a name="classes"></a>Klassen

| Klasse    |  Beschreibung |
|:-------------|:---------------|
| [`Environment`](./sp-core-library/environment.md)     | Diese Klasse enthält kontextbezogene Informationen zur Umgebung, die das Framework und die zugehörigen Komponenten hostet. |
| [`Guid`](./sp-core-library/guid.md)     | Diese Klasse stellt einen Globally Unique Identifier (Global eindeutiger Bezeichner) dar, wie von IETF RFC 4122 beschrieben. Die Eingabezeichenfolge ist normalisiert und überprüft, was wichtige Garantien bereitstellt, die anderen Code vereinfachen, der mit der GUID funktioniert. Diese Klasse stellt außerdem grundlegende Unterstützung für das Generieren einer pseudozufälligen GUID bereit. Beachten Sie jedoch, dass die Eindeutigkeit von der Math.random()-Funktion des Browsers abhängt und möglicherweise für einige Anwendungen nicht geeignet ist. |
| [`Log`](./sp-core-library/log.md)     | Die Log-Klasse stellt statische Methoden zum Protokollieren von Meldungen auf unterschiedlichen Ebenen (ausführliche, Information, Warnung, Fehler) und mit Kontextinformationen bereit. Kontextinformationen helfen bei der Identifizierung, welche Komponente die Meldungen generiert hat, und gestalten die Meldung hilfreich und filterbar. |
| [`RandomNumberGenerator`](./sp-core-library/randomnumbergenerator.md)     | Dies ist die standardmäßige Implementierung von IRandomNumberGenerator, die einfach Math.random() aufruft. |
| [`ServiceKey`](./sp-core-library/servicekey.md)     | Der SericeKey ist ein Suchschlüssel, der beim Aufrufen von ServiceScope.consume() zum Abrufen einer Abhängigkeit verwendet wird. Der Schlüssel definiert auch eine Standardimplementierung der Abhängigkeit, die vom Stammbereich automatisch erstellt wird, wenn die Abhängigkeit nicht gefunden wird. Durch Bereitstellen einer Standardimplementierung wird sichergestellt, dass neue Abhängigkeiten bedenkenlos eingeführt werden können, ohne versehentlich Komponenten zu zerstören, die von einem älteren Host geladen werden (der nicht die neue Abhängigkeit bereitstellt). |
| [`ServiceScope`](./sp-core-library/servicescope.md)     | ServiceScope bietet eine formalisierte Möglichkeit für Komponenten zum Registrieren und Nutzen von Abhängigkeiten („Diensten“) sowie die Möglichkeit, dass unterschiedliche Implementierungen in unterschiedlichen Bereichen registriert werden. Dadurch wird die Modularität durch Entkopplung von Komponenten von ihren Abhängigkeiten wesentlich verbessert. Angenommen, verschiedene Komponenten müssen auf eine IPageManager-Instanz zugreifen. Wir könnten den PageManager einfach als Singleton (d. h. als globale Variable) erstellen, dies funktioniert aber nicht, wenn wir beispielsweise ein Popupfenster erstellen müssen, für das eine zweite PageManager-Instanz erforderlich ist. Eine bessere Lösung wäre, PageManager als Konstruktorparameter für die einzelnen Komponenten hinzufügen, für die er erforderlich ist. Dann sehen wir uns jedoch unmittelbar mit dem Problem konfrontiert, dass der Code, der diese Konstruktoren aufruft, auch einen PageManager-Parameter benötigt. In einer Anwendung mit vielen solchen Abhängigkeiten würde die Geschäftslogik, die viele Teilsysteme miteinander verbindet, schließlich einen Konstruktorparameter für jede möglichen Abhängigkeit aufnehmen, was sehr unübersichtlich ist. Eine natürliche Lösung wäre es, alle Abhängigkeiten in eine Klasse mit einem Namen wie „"ApplicationContext“ zu verschieben und dann diese als Konstruktorparameter zu übergeben. Dadurch kann PageManager an Klassen übergeben werden, die diesen benötigen, ohne die Zwischenklassen zu beeinträchtigen, die ihn nicht benötigen. Es ist jedoch immer noch ein Entwurfsproblem, dass „ApplicationContext“ hartcodierte Abhängigkeiten bei vielen nicht miteinander verknüpften Aktionen aufweist. Ein flexiblerer Ansatz besteht darin, ein Wörterbuch daraus zu erstellen, das Elemente für Verbraucher/Anbieter nachschlagen kann, die den korrekten Nachschlageschlüssel (d. h. ServiceKey) kennen. Dies ist das beliebte „service Locator“-Entwurfsmuster, das wir aus der SPContext-API im klassischen SharePoint kennen. Bei ServiceScope wird diese Idee auf zweierlei Arten einen Schritt weiter geführt: Zunächst stellt es einen Mechanismus für die Bereichsdefinition bereit, sodass zwei unterschiedliche Seiten jeweils eine eindeutige PageManager-Instanz verwenden könnten, während weiterhin andere gemeinsame Abhängigkeiten gemeinsam verwendet werden. Außerdem kann ein ServiceKey eine Standardimplementierung der Abhängigkeit bereitstellen. Dies ist für die API-Stabilität in unserer modularen clientseitigen Umgebung wichtig: Angenommen, in Version 2.0 unserer Anwendung würde eine neue IDiagnosticTracing-Schnittstelle eingeführt, die von einer Komponente der Version 2.0 verwendet wird. Wenn die Version 2.0-Komponente von einer älteren 1.0-Anwendung geladen wird, würde ein Fehler auftreten. Dieser Fehler könnte behoben werden, indem jeder Verbraucher nach fehlenden Abhängigkeiten suchen und diesen Fall lösen muss, hierfür wären aber viele Überprüfungen erforderlich. Eine bessere Lösung besteht darin, sicherzustellen, dass immer eine Standardimplementierung vorhanden ist, vielleicht nur ein Testverhalten, damit Komponenten sich nicht darum kümmern müssen. Verwendung: ServiceScope-Instanzen werden durch Aufrufen von ServiceScope.startNewRoot() oder ServiceScope.startNewChild() erstellt. Sie befinden sich zunächst in einem „nicht abgeschlossenen“ Zustand, in dem provide() aufgerufen werden kann, um Dienstschlüssel zu registrieren, consume() ist jedoch verboten. Nachdem ServiceScope.finish() aufgerufen wurde, ist consume() zulässig, und provide() ist nun verboten. Durch diese Semantik wird sichergestellt, dass ServiceScope.consume() immer dasselbe Ergebnis für denselben Schlüssel zurückgibt und nicht von der Reihenfolge der Initialisierung abhängig ist. Außerdem können wir Ringabhängigkeiten unterstützen, ohne dass wir uns um unendliche Schleifen Gedanken machen müssen, wenn wir mit externen Komponenten arbeiten, die von Drittanbietern implementiert wurden. Um Fehler zu vermeiden, empfiehlt es sich immer, consume() innerhalb eines Rückrufs vom serviceScope.whenFinished() aufzurufen. |
| [`TimeProvider`](./sp-core-library/timeprovider.md)     | Dies ist die standardmäßige Implementierung von ITimeProvider, durch die einfach die realen Browser-APIs aufgerufen werden. |
| [`UrlQueryParameterCollection`](./sp-core-library/urlqueryparametercollection.md)     | Klasse für das Speichern und Abrufen von Abfrageparametern. Die URL kann serverbezogen sein und analysiert leere/NULL-Zeichenfolgen. Die Abfrageparameter müssen mit „?“ beginnen, um den ersten Abfrageparameter anzuzeigen, und „&“ für alle nachfolgenden Parameter verwenden. Die Klasse unterstützt auch Fragmente. Verhalten von Edge-Fällen: Leerer Wert (www.example.com/?test=) speichert Schlüssel und leeren Wert Keine Gleichheitszeichen in queryParam (www.example.com/?test) speichert Schlüssel und undefinierten Wert Leerer queryParam (www.example.com/?&debug=on) speichert undefinierten Schlüssel und Wert und Wert Abfrageparameter nur mit Gleichheitszeichen (www.example.com/?=&debug=on) speichert leeren Zeichenfolgenschlüssel und -wert |
| [`UrlUtilities`](./sp-core-library/urlutilities.md)     | Häufig verwendete Hilfsfunktionen für das Arbeiten mit URLs. Diese Dienstprogramme sollen einfach, klein und vielfältig anwendbar sein. |
| [`Validate`](./sp-core-library/validate.md)     | Diese Klasse implementiert ein Standardverfahren zum Überprüfen von Eigenschaften und Funktionsparametern. Im Gegensatz zu Debugassertionen werden Validate-Überprüfungen immer durchgeführt und lösen immer einen Fehler aus, auch in einer Produktionsversion. Achten Sie daher darauf, diese Überprüfungen nicht zu häufig zu verwenden, damit die Leistung nicht beeinträchtigt wird. |
| [`Version`](./sp-core-library/version.md)     | Diese Klasse stellt Versionen dar, die das Zeichenfolgenformat MAJOR.MINOR[.PATCH[.REVISION]] aufweisen, wobei MAJOR, MINOR, PATCH und REVISION ganze Zahlen sind. PATCH und REVISION sind optional. Vorangestellte Nullen sind zulässig, haben aber bei Vergleichen keine Bedeutung. Beispiele: 1.0, 1.0.0, 1.0.0.0, 1.01, 01.02.03, 001.002.003.004 |



## <a name="interfaces"></a>Schnittstellen

| Schnittstelle    |  Beschreibung |
|:-------------|:---------------|
| [`IRandomNumberGenerator`](./sp-core-library/irandomnumbergenerator.md)   | Dies ist eine ServiceScope-Schnittstelle, über die Komponententests eine deterministische Quelle für Pseudozufallszahlen bereitstellen können.  |
| [`IServiceCollection`](./sp-core-library/iservicecollection.md)   | Ein Muster in Kurzschrift zum Extrahieren bekannter Dienste aus einem ServiceScope.  |
| [`ITimeProvider`](./sp-core-library/itimeprovider.md)   | Dies ist eine ServiceScope-Schnittstelle, über die Komponententests die Systemuhr simulieren können.  |



## <a name="enumerations"></a>Enumerationen

| Enumeration      | Beschreibung|
|:-----------|:------------|
|[`DisplayMode`](./sp-core-library/displaymode.md)    | DisplayMode gibt den Modus an, in dem eine Seite und/oder deren Inhalt (z. B. Text und Webparts) angezeigt werden. |
|[`EnvironmentType`](./sp-core-library/environmenttype.md)    | Eine Aufzählung, die beschreibt, in welcher Art von Umgebung das Framework ausgeführt wird. |




